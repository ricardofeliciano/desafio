{"ast":null,"code":"import { getTimezoneOffsetInMilliseconds } from '../_lib/getTimezoneOffsetInMilliseconds/index.js';\nimport { tzParseTimezone } from '../_lib/tzParseTimezone/index.js';\nimport { tzPattern } from '../_lib/tzPattern/index.js';\nconst MILLISECONDS_IN_HOUR = 3600000;\nconst MILLISECONDS_IN_MINUTE = 60000;\nconst DEFAULT_ADDITIONAL_DIGITS = 2;\nconst patterns = {\n  dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,\n  datePattern: /^([0-9W+-]+)(.*)/,\n  plainTime: /:/,\n  // year tokens\n  YY: /^(\\d{2})$/,\n  YYY: [/^([+-]\\d{2})$/,\n  // 0 additional digits\n  /^([+-]\\d{3})$/,\n  // 1 additional digit\n  /^([+-]\\d{4})$/ // 2 additional digits\n  ],\n  YYYY: /^(\\d{4})/,\n  YYYYY: [/^([+-]\\d{4})/,\n  // 0 additional digits\n  /^([+-]\\d{5})/,\n  // 1 additional digit\n  /^([+-]\\d{6})/ // 2 additional digits\n  ],\n  // date tokens\n  MM: /^-(\\d{2})$/,\n  DDD: /^-?(\\d{3})$/,\n  MMDD: /^-?(\\d{2})-?(\\d{2})$/,\n  Www: /^-?W(\\d{2})$/,\n  WwwD: /^-?W(\\d{2})-?(\\d{1})$/,\n  HH: /^(\\d{2}([.,]\\d*)?)$/,\n  HHMM: /^(\\d{2}):?(\\d{2}([.,]\\d*)?)$/,\n  HHMMSS: /^(\\d{2}):?(\\d{2}):?(\\d{2}([.,]\\d*)?)$/,\n  // time zone tokens (to identify the presence of a tz)\n  timeZone: tzPattern\n};\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If an argument is a string, the function tries to parse it.\n * Function accepts complete ISO 8601 formats as well as partial implementations.\n * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601\n * If the function cannot parse the string or the values are invalid, it returns Invalid Date.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.\n *\n * @param argument the value to convert\n * @param options the object with options. See [Options]{@link https://date-fns.org/docs/Options}\n * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format\n * @param {string} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.\n *\n * @returns the parsed date in the local time zone\n * @throws {TypeError} 1 argument required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n *\n * @example\n * // Convert string '2014-02-11T11:30:30' to date:\n * const result = toDate('2014-02-11T11:30:30')\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert string '+02014101' to date,\n * // if the additional number of digits in the extended year format is 1:\n * const result = toDate('+02014101', {additionalDigits: 1})\n * //=> Fri Apr 11 2014 00:00:00\n */\nexport function toDate(argument, options = {}) {\n  if (arguments.length < 1) {\n    throw new TypeError('1 argument required, but only ' + arguments.length + ' present');\n  }\n  if (argument === null) {\n    return new Date(NaN);\n  }\n  const additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : Number(options.additionalDigits);\n  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {\n    throw new RangeError('additionalDigits must be 0, 1 or 2');\n  }\n  // Clone the date\n  if (argument instanceof Date || typeof argument === 'object' && Object.prototype.toString.call(argument) === '[object Date]') {\n    // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n    return new Date(argument.getTime());\n  } else if (typeof argument === 'number' || Object.prototype.toString.call(argument) === '[object Number]') {\n    return new Date(argument);\n  } else if (!(Object.prototype.toString.call(argument) === '[object String]')) {\n    return new Date(NaN);\n  }\n  const dateStrings = splitDateString(argument);\n  const {\n    year,\n    restDateString\n  } = parseYear(dateStrings.date, additionalDigits);\n  const date = parseDate(restDateString, year);\n  if (date === null || isNaN(date.getTime())) {\n    return new Date(NaN);\n  }\n  if (date) {\n    const timestamp = date.getTime();\n    let time = 0;\n    let offset;\n    if (dateStrings.time) {\n      time = parseTime(dateStrings.time);\n      if (time === null || isNaN(time)) {\n        return new Date(NaN);\n      }\n    }\n    if (dateStrings.timeZone || options.timeZone) {\n      offset = tzParseTimezone(dateStrings.timeZone || options.timeZone, new Date(timestamp + time));\n      if (isNaN(offset)) {\n        return new Date(NaN);\n      }\n    } else {\n      // get offset accurate to hour in time zones that change offset\n      offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time));\n      offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time + offset));\n    }\n    return new Date(timestamp + time + offset);\n  } else {\n    return new Date(NaN);\n  }\n}\nfunction splitDateString(dateString) {\n  const dateStrings = {};\n  let parts = patterns.dateTimePattern.exec(dateString);\n  let timeString;\n  if (!parts) {\n    parts = patterns.datePattern.exec(dateString);\n    if (parts) {\n      dateStrings.date = parts[1];\n      timeString = parts[2];\n    } else {\n      dateStrings.date = null;\n      timeString = dateString;\n    }\n  } else {\n    dateStrings.date = parts[1];\n    timeString = parts[3];\n  }\n  if (timeString) {\n    const token = patterns.timeZone.exec(timeString);\n    if (token) {\n      dateStrings.time = timeString.replace(token[1], '');\n      dateStrings.timeZone = token[1].trim();\n    } else {\n      dateStrings.time = timeString;\n    }\n  }\n  return dateStrings;\n}\nfunction parseYear(dateString, additionalDigits) {\n  if (dateString) {\n    const patternYYY = patterns.YYY[additionalDigits];\n    const patternYYYYY = patterns.YYYYY[additionalDigits];\n    // YYYY or ±YYYYY\n    let token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);\n    if (token) {\n      const yearString = token[1];\n      return {\n        year: parseInt(yearString, 10),\n        restDateString: dateString.slice(yearString.length)\n      };\n    }\n    // YY or ±YYY\n    token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);\n    if (token) {\n      const centuryString = token[1];\n      return {\n        year: parseInt(centuryString, 10) * 100,\n        restDateString: dateString.slice(centuryString.length)\n      };\n    }\n  }\n  // Invalid ISO-formatted year\n  return {\n    year: null\n  };\n}\nfunction parseDate(dateString, year) {\n  // Invalid ISO-formatted year\n  if (year === null) {\n    return null;\n  }\n  let date;\n  let month;\n  let week;\n  // YYYY\n  if (!dateString || !dateString.length) {\n    date = new Date(0);\n    date.setUTCFullYear(year);\n    return date;\n  }\n  // YYYY-MM\n  let token = patterns.MM.exec(dateString);\n  if (token) {\n    date = new Date(0);\n    month = parseInt(token[1], 10) - 1;\n    if (!validateDate(year, month)) {\n      return new Date(NaN);\n    }\n    date.setUTCFullYear(year, month);\n    return date;\n  }\n  // YYYY-DDD or YYYYDDD\n  token = patterns.DDD.exec(dateString);\n  if (token) {\n    date = new Date(0);\n    const dayOfYear = parseInt(token[1], 10);\n    if (!validateDayOfYearDate(year, dayOfYear)) {\n      return new Date(NaN);\n    }\n    date.setUTCFullYear(year, 0, dayOfYear);\n    return date;\n  }\n  // yyyy-MM-dd or YYYYMMDD\n  token = patterns.MMDD.exec(dateString);\n  if (token) {\n    date = new Date(0);\n    month = parseInt(token[1], 10) - 1;\n    const day = parseInt(token[2], 10);\n    if (!validateDate(year, month, day)) {\n      return new Date(NaN);\n    }\n    date.setUTCFullYear(year, month, day);\n    return date;\n  }\n  // YYYY-Www or YYYYWww\n  token = patterns.Www.exec(dateString);\n  if (token) {\n    week = parseInt(token[1], 10) - 1;\n    if (!validateWeekDate(week)) {\n      return new Date(NaN);\n    }\n    return dayOfISOWeekYear(year, week);\n  }\n  // YYYY-Www-D or YYYYWwwD\n  token = patterns.WwwD.exec(dateString);\n  if (token) {\n    week = parseInt(token[1], 10) - 1;\n    const dayOfWeek = parseInt(token[2], 10) - 1;\n    if (!validateWeekDate(week, dayOfWeek)) {\n      return new Date(NaN);\n    }\n    return dayOfISOWeekYear(year, week, dayOfWeek);\n  }\n  // Invalid ISO-formatted date\n  return null;\n}\nfunction parseTime(timeString) {\n  let hours;\n  let minutes;\n  // hh\n  let token = patterns.HH.exec(timeString);\n  if (token) {\n    hours = parseFloat(token[1].replace(',', '.'));\n    if (!validateTime(hours)) {\n      return NaN;\n    }\n    return hours % 24 * MILLISECONDS_IN_HOUR;\n  }\n  // hh:mm or hhmm\n  token = patterns.HHMM.exec(timeString);\n  if (token) {\n    hours = parseInt(token[1], 10);\n    minutes = parseFloat(token[2].replace(',', '.'));\n    if (!validateTime(hours, minutes)) {\n      return NaN;\n    }\n    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;\n  }\n  // hh:mm:ss or hhmmss\n  token = patterns.HHMMSS.exec(timeString);\n  if (token) {\n    hours = parseInt(token[1], 10);\n    minutes = parseInt(token[2], 10);\n    const seconds = parseFloat(token[3].replace(',', '.'));\n    if (!validateTime(hours, minutes, seconds)) {\n      return NaN;\n    }\n    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;\n  }\n  // Invalid ISO-formatted time\n  return null;\n}\nfunction dayOfISOWeekYear(isoWeekYear, week, day) {\n  week = week || 0;\n  day = day || 0;\n  const date = new Date(0);\n  date.setUTCFullYear(isoWeekYear, 0, 4);\n  const fourthOfJanuaryDay = date.getUTCDay() || 7;\n  const diff = week * 7 + day + 1 - fourthOfJanuaryDay;\n  date.setUTCDate(date.getUTCDate() + diff);\n  return date;\n}\n// Validation functions\nconst DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nfunction isLeapYearIndex(year) {\n  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;\n}\nfunction validateDate(year, month, date) {\n  if (month < 0 || month > 11) {\n    return false;\n  }\n  if (date != null) {\n    if (date < 1) {\n      return false;\n    }\n    const isLeapYear = isLeapYearIndex(year);\n    if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {\n      return false;\n    }\n    if (!isLeapYear && date > DAYS_IN_MONTH[month]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction validateDayOfYearDate(year, dayOfYear) {\n  if (dayOfYear < 1) {\n    return false;\n  }\n  const isLeapYear = isLeapYearIndex(year);\n  if (isLeapYear && dayOfYear > 366) {\n    return false;\n  }\n  if (!isLeapYear && dayOfYear > 365) {\n    return false;\n  }\n  return true;\n}\nfunction validateWeekDate(week, day) {\n  if (week < 0 || week > 52) {\n    return false;\n  }\n  if (day != null && (day < 0 || day > 6)) {\n    return false;\n  }\n  return true;\n}\nfunction validateTime(hours, minutes, seconds) {\n  if (hours < 0 || hours >= 25) {\n    return false;\n  }\n  if (minutes != null && (minutes < 0 || minutes >= 60)) {\n    return false;\n  }\n  if (seconds != null && (seconds < 0 || seconds >= 60)) {\n    return false;\n  }\n  return true;\n}","map":{"version":3,"names":["getTimezoneOffsetInMilliseconds","tzParseTimezone","tzPattern","MILLISECONDS_IN_HOUR","MILLISECONDS_IN_MINUTE","DEFAULT_ADDITIONAL_DIGITS","patterns","dateTimePattern","datePattern","plainTime","YY","YYY","YYYY","YYYYY","MM","DDD","MMDD","Www","WwwD","HH","HHMM","HHMMSS","timeZone","toDate","argument","options","arguments","length","TypeError","Date","NaN","additionalDigits","Number","RangeError","Object","prototype","toString","call","getTime","dateStrings","splitDateString","year","restDateString","parseYear","date","parseDate","isNaN","timestamp","time","offset","parseTime","dateString","parts","exec","timeString","token","replace","trim","patternYYY","patternYYYYY","yearString","parseInt","slice","centuryString","month","week","setUTCFullYear","validateDate","dayOfYear","validateDayOfYearDate","day","validateWeekDate","dayOfISOWeekYear","dayOfWeek","hours","minutes","parseFloat","validateTime","seconds","isoWeekYear","fourthOfJanuaryDay","getUTCDay","diff","setUTCDate","getUTCDate","DAYS_IN_MONTH","DAYS_IN_MONTH_LEAP_YEAR","isLeapYearIndex","isLeapYear"],"sources":["C:/Users/WTINFO PC/Desktop/desafio/desafio-frontend/node_modules/date-fns-tz/dist/esm/toDate/index.js"],"sourcesContent":["import { getTimezoneOffsetInMilliseconds } from '../_lib/getTimezoneOffsetInMilliseconds/index.js';\nimport { tzParseTimezone } from '../_lib/tzParseTimezone/index.js';\nimport { tzPattern } from '../_lib/tzPattern/index.js';\nconst MILLISECONDS_IN_HOUR = 3600000;\nconst MILLISECONDS_IN_MINUTE = 60000;\nconst DEFAULT_ADDITIONAL_DIGITS = 2;\nconst patterns = {\n    dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,\n    datePattern: /^([0-9W+-]+)(.*)/,\n    plainTime: /:/,\n    // year tokens\n    YY: /^(\\d{2})$/,\n    YYY: [\n        /^([+-]\\d{2})$/, // 0 additional digits\n        /^([+-]\\d{3})$/, // 1 additional digit\n        /^([+-]\\d{4})$/, // 2 additional digits\n    ],\n    YYYY: /^(\\d{4})/,\n    YYYYY: [\n        /^([+-]\\d{4})/, // 0 additional digits\n        /^([+-]\\d{5})/, // 1 additional digit\n        /^([+-]\\d{6})/, // 2 additional digits\n    ],\n    // date tokens\n    MM: /^-(\\d{2})$/,\n    DDD: /^-?(\\d{3})$/,\n    MMDD: /^-?(\\d{2})-?(\\d{2})$/,\n    Www: /^-?W(\\d{2})$/,\n    WwwD: /^-?W(\\d{2})-?(\\d{1})$/,\n    HH: /^(\\d{2}([.,]\\d*)?)$/,\n    HHMM: /^(\\d{2}):?(\\d{2}([.,]\\d*)?)$/,\n    HHMMSS: /^(\\d{2}):?(\\d{2}):?(\\d{2}([.,]\\d*)?)$/,\n    // time zone tokens (to identify the presence of a tz)\n    timeZone: tzPattern,\n};\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If an argument is a string, the function tries to parse it.\n * Function accepts complete ISO 8601 formats as well as partial implementations.\n * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601\n * If the function cannot parse the string or the values are invalid, it returns Invalid Date.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.\n *\n * @param argument the value to convert\n * @param options the object with options. See [Options]{@link https://date-fns.org/docs/Options}\n * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format\n * @param {string} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.\n *\n * @returns the parsed date in the local time zone\n * @throws {TypeError} 1 argument required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n *\n * @example\n * // Convert string '2014-02-11T11:30:30' to date:\n * const result = toDate('2014-02-11T11:30:30')\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert string '+02014101' to date,\n * // if the additional number of digits in the extended year format is 1:\n * const result = toDate('+02014101', {additionalDigits: 1})\n * //=> Fri Apr 11 2014 00:00:00\n */\nexport function toDate(argument, options = {}) {\n    if (arguments.length < 1) {\n        throw new TypeError('1 argument required, but only ' + arguments.length + ' present');\n    }\n    if (argument === null) {\n        return new Date(NaN);\n    }\n    const additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : Number(options.additionalDigits);\n    if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {\n        throw new RangeError('additionalDigits must be 0, 1 or 2');\n    }\n    // Clone the date\n    if (argument instanceof Date ||\n        (typeof argument === 'object' && Object.prototype.toString.call(argument) === '[object Date]')) {\n        // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n        return new Date(argument.getTime());\n    }\n    else if (typeof argument === 'number' ||\n        Object.prototype.toString.call(argument) === '[object Number]') {\n        return new Date(argument);\n    }\n    else if (!(Object.prototype.toString.call(argument) === '[object String]')) {\n        return new Date(NaN);\n    }\n    const dateStrings = splitDateString(argument);\n    const { year, restDateString } = parseYear(dateStrings.date, additionalDigits);\n    const date = parseDate(restDateString, year);\n    if (date === null || isNaN(date.getTime())) {\n        return new Date(NaN);\n    }\n    if (date) {\n        const timestamp = date.getTime();\n        let time = 0;\n        let offset;\n        if (dateStrings.time) {\n            time = parseTime(dateStrings.time);\n            if (time === null || isNaN(time)) {\n                return new Date(NaN);\n            }\n        }\n        if (dateStrings.timeZone || options.timeZone) {\n            offset = tzParseTimezone(dateStrings.timeZone || options.timeZone, new Date(timestamp + time));\n            if (isNaN(offset)) {\n                return new Date(NaN);\n            }\n        }\n        else {\n            // get offset accurate to hour in time zones that change offset\n            offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time));\n            offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time + offset));\n        }\n        return new Date(timestamp + time + offset);\n    }\n    else {\n        return new Date(NaN);\n    }\n}\nfunction splitDateString(dateString) {\n    const dateStrings = {};\n    let parts = patterns.dateTimePattern.exec(dateString);\n    let timeString;\n    if (!parts) {\n        parts = patterns.datePattern.exec(dateString);\n        if (parts) {\n            dateStrings.date = parts[1];\n            timeString = parts[2];\n        }\n        else {\n            dateStrings.date = null;\n            timeString = dateString;\n        }\n    }\n    else {\n        dateStrings.date = parts[1];\n        timeString = parts[3];\n    }\n    if (timeString) {\n        const token = patterns.timeZone.exec(timeString);\n        if (token) {\n            dateStrings.time = timeString.replace(token[1], '');\n            dateStrings.timeZone = token[1].trim();\n        }\n        else {\n            dateStrings.time = timeString;\n        }\n    }\n    return dateStrings;\n}\nfunction parseYear(dateString, additionalDigits) {\n    if (dateString) {\n        const patternYYY = patterns.YYY[additionalDigits];\n        const patternYYYYY = patterns.YYYYY[additionalDigits];\n        // YYYY or ±YYYYY\n        let token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);\n        if (token) {\n            const yearString = token[1];\n            return {\n                year: parseInt(yearString, 10),\n                restDateString: dateString.slice(yearString.length),\n            };\n        }\n        // YY or ±YYY\n        token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);\n        if (token) {\n            const centuryString = token[1];\n            return {\n                year: parseInt(centuryString, 10) * 100,\n                restDateString: dateString.slice(centuryString.length),\n            };\n        }\n    }\n    // Invalid ISO-formatted year\n    return {\n        year: null,\n    };\n}\nfunction parseDate(dateString, year) {\n    // Invalid ISO-formatted year\n    if (year === null) {\n        return null;\n    }\n    let date;\n    let month;\n    let week;\n    // YYYY\n    if (!dateString || !dateString.length) {\n        date = new Date(0);\n        date.setUTCFullYear(year);\n        return date;\n    }\n    // YYYY-MM\n    let token = patterns.MM.exec(dateString);\n    if (token) {\n        date = new Date(0);\n        month = parseInt(token[1], 10) - 1;\n        if (!validateDate(year, month)) {\n            return new Date(NaN);\n        }\n        date.setUTCFullYear(year, month);\n        return date;\n    }\n    // YYYY-DDD or YYYYDDD\n    token = patterns.DDD.exec(dateString);\n    if (token) {\n        date = new Date(0);\n        const dayOfYear = parseInt(token[1], 10);\n        if (!validateDayOfYearDate(year, dayOfYear)) {\n            return new Date(NaN);\n        }\n        date.setUTCFullYear(year, 0, dayOfYear);\n        return date;\n    }\n    // yyyy-MM-dd or YYYYMMDD\n    token = patterns.MMDD.exec(dateString);\n    if (token) {\n        date = new Date(0);\n        month = parseInt(token[1], 10) - 1;\n        const day = parseInt(token[2], 10);\n        if (!validateDate(year, month, day)) {\n            return new Date(NaN);\n        }\n        date.setUTCFullYear(year, month, day);\n        return date;\n    }\n    // YYYY-Www or YYYYWww\n    token = patterns.Www.exec(dateString);\n    if (token) {\n        week = parseInt(token[1], 10) - 1;\n        if (!validateWeekDate(week)) {\n            return new Date(NaN);\n        }\n        return dayOfISOWeekYear(year, week);\n    }\n    // YYYY-Www-D or YYYYWwwD\n    token = patterns.WwwD.exec(dateString);\n    if (token) {\n        week = parseInt(token[1], 10) - 1;\n        const dayOfWeek = parseInt(token[2], 10) - 1;\n        if (!validateWeekDate(week, dayOfWeek)) {\n            return new Date(NaN);\n        }\n        return dayOfISOWeekYear(year, week, dayOfWeek);\n    }\n    // Invalid ISO-formatted date\n    return null;\n}\nfunction parseTime(timeString) {\n    let hours;\n    let minutes;\n    // hh\n    let token = patterns.HH.exec(timeString);\n    if (token) {\n        hours = parseFloat(token[1].replace(',', '.'));\n        if (!validateTime(hours)) {\n            return NaN;\n        }\n        return (hours % 24) * MILLISECONDS_IN_HOUR;\n    }\n    // hh:mm or hhmm\n    token = patterns.HHMM.exec(timeString);\n    if (token) {\n        hours = parseInt(token[1], 10);\n        minutes = parseFloat(token[2].replace(',', '.'));\n        if (!validateTime(hours, minutes)) {\n            return NaN;\n        }\n        return (hours % 24) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;\n    }\n    // hh:mm:ss or hhmmss\n    token = patterns.HHMMSS.exec(timeString);\n    if (token) {\n        hours = parseInt(token[1], 10);\n        minutes = parseInt(token[2], 10);\n        const seconds = parseFloat(token[3].replace(',', '.'));\n        if (!validateTime(hours, minutes, seconds)) {\n            return NaN;\n        }\n        return (hours % 24) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;\n    }\n    // Invalid ISO-formatted time\n    return null;\n}\nfunction dayOfISOWeekYear(isoWeekYear, week, day) {\n    week = week || 0;\n    day = day || 0;\n    const date = new Date(0);\n    date.setUTCFullYear(isoWeekYear, 0, 4);\n    const fourthOfJanuaryDay = date.getUTCDay() || 7;\n    const diff = week * 7 + day + 1 - fourthOfJanuaryDay;\n    date.setUTCDate(date.getUTCDate() + diff);\n    return date;\n}\n// Validation functions\nconst DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nfunction isLeapYearIndex(year) {\n    return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);\n}\nfunction validateDate(year, month, date) {\n    if (month < 0 || month > 11) {\n        return false;\n    }\n    if (date != null) {\n        if (date < 1) {\n            return false;\n        }\n        const isLeapYear = isLeapYearIndex(year);\n        if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {\n            return false;\n        }\n        if (!isLeapYear && date > DAYS_IN_MONTH[month]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction validateDayOfYearDate(year, dayOfYear) {\n    if (dayOfYear < 1) {\n        return false;\n    }\n    const isLeapYear = isLeapYearIndex(year);\n    if (isLeapYear && dayOfYear > 366) {\n        return false;\n    }\n    if (!isLeapYear && dayOfYear > 365) {\n        return false;\n    }\n    return true;\n}\nfunction validateWeekDate(week, day) {\n    if (week < 0 || week > 52) {\n        return false;\n    }\n    if (day != null && (day < 0 || day > 6)) {\n        return false;\n    }\n    return true;\n}\nfunction validateTime(hours, minutes, seconds) {\n    if (hours < 0 || hours >= 25) {\n        return false;\n    }\n    if (minutes != null && (minutes < 0 || minutes >= 60)) {\n        return false;\n    }\n    if (seconds != null && (seconds < 0 || seconds >= 60)) {\n        return false;\n    }\n    return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}