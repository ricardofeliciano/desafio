{"ast":null,"code":"/**\n * Returns the formatted time zone name of the provided `timeZone` or the current\n * system time zone if omitted, accounting for DST according to the UTC value of\n * the date.\n */\nexport function tzIntlTimeZoneName(length, date, options) {\n  const dtf = getDTF(length, options.timeZone, options.locale);\n  return 'formatToParts' in dtf ? partsTimeZone(dtf, date) : hackyTimeZone(dtf, date);\n}\nfunction partsTimeZone(dtf, date) {\n  const formatted = dtf.formatToParts(date);\n  for (let i = formatted.length - 1; i >= 0; --i) {\n    if (formatted[i].type === 'timeZoneName') {\n      return formatted[i].value;\n    }\n  }\n  return undefined;\n}\nfunction hackyTimeZone(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, '');\n  const tzNameMatch = / [\\w-+ ]+$/.exec(formatted);\n  return tzNameMatch ? tzNameMatch[0].substr(1) : '';\n}\n// If a locale has been provided `en-US` is used as a fallback in case it is an\n// invalid locale, otherwise the locale is left undefined to use the system locale.\nfunction getDTF(length, timeZone, locale) {\n  return new Intl.DateTimeFormat(locale ? [locale.code, 'en-US'] : undefined, {\n    timeZone: timeZone,\n    timeZoneName: length\n  });\n}","map":{"version":3,"names":["tzIntlTimeZoneName","length","date","options","dtf","getDTF","timeZone","locale","partsTimeZone","hackyTimeZone","formatted","formatToParts","i","type","value","undefined","format","replace","tzNameMatch","exec","substr","Intl","DateTimeFormat","code","timeZoneName"],"sources":["C:/Users/WTINFO PC/Desktop/desafio/desafio-frontend/node_modules/date-fns-tz/dist/esm/_lib/tzIntlTimeZoneName/index.js"],"sourcesContent":["/**\n * Returns the formatted time zone name of the provided `timeZone` or the current\n * system time zone if omitted, accounting for DST according to the UTC value of\n * the date.\n */\nexport function tzIntlTimeZoneName(length, date, options) {\n    const dtf = getDTF(length, options.timeZone, options.locale);\n    return 'formatToParts' in dtf ? partsTimeZone(dtf, date) : hackyTimeZone(dtf, date);\n}\nfunction partsTimeZone(dtf, date) {\n    const formatted = dtf.formatToParts(date);\n    for (let i = formatted.length - 1; i >= 0; --i) {\n        if (formatted[i].type === 'timeZoneName') {\n            return formatted[i].value;\n        }\n    }\n    return undefined;\n}\nfunction hackyTimeZone(dtf, date) {\n    const formatted = dtf.format(date).replace(/\\u200E/g, '');\n    const tzNameMatch = / [\\w-+ ]+$/.exec(formatted);\n    return tzNameMatch ? tzNameMatch[0].substr(1) : '';\n}\n// If a locale has been provided `en-US` is used as a fallback in case it is an\n// invalid locale, otherwise the locale is left undefined to use the system locale.\nfunction getDTF(length, timeZone, locale) {\n    return new Intl.DateTimeFormat(locale ? [locale.code, 'en-US'] : undefined, {\n        timeZone: timeZone,\n        timeZoneName: length,\n    });\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,kBAAkBA,CAACC,MAAM,EAAEC,IAAI,EAAEC,OAAO,EAAE;EACtD,MAAMC,GAAG,GAAGC,MAAM,CAACJ,MAAM,EAAEE,OAAO,CAACG,QAAQ,EAAEH,OAAO,CAACI,MAAM,CAAC;EAC5D,OAAO,eAAe,IAAIH,GAAG,GAAGI,aAAa,CAACJ,GAAG,EAAEF,IAAI,CAAC,GAAGO,aAAa,CAACL,GAAG,EAAEF,IAAI,CAAC;AACvF;AACA,SAASM,aAAaA,CAACJ,GAAG,EAAEF,IAAI,EAAE;EAC9B,MAAMQ,SAAS,GAAGN,GAAG,CAACO,aAAa,CAACT,IAAI,CAAC;EACzC,KAAK,IAAIU,CAAC,GAAGF,SAAS,CAACT,MAAM,GAAG,CAAC,EAAEW,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;IAC5C,IAAIF,SAAS,CAACE,CAAC,CAAC,CAACC,IAAI,KAAK,cAAc,EAAE;MACtC,OAAOH,SAAS,CAACE,CAAC,CAAC,CAACE,KAAK;IAC7B;EACJ;EACA,OAAOC,SAAS;AACpB;AACA,SAASN,aAAaA,CAACL,GAAG,EAAEF,IAAI,EAAE;EAC9B,MAAMQ,SAAS,GAAGN,GAAG,CAACY,MAAM,CAACd,IAAI,CAAC,CAACe,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC;EACzD,MAAMC,WAAW,GAAG,YAAY,CAACC,IAAI,CAACT,SAAS,CAAC;EAChD,OAAOQ,WAAW,GAAGA,WAAW,CAAC,CAAC,CAAC,CAACE,MAAM,CAAC,CAAC,CAAC,GAAG,EAAE;AACtD;AACA;AACA;AACA,SAASf,MAAMA,CAACJ,MAAM,EAAEK,QAAQ,EAAEC,MAAM,EAAE;EACtC,OAAO,IAAIc,IAAI,CAACC,cAAc,CAACf,MAAM,GAAG,CAACA,MAAM,CAACgB,IAAI,EAAE,OAAO,CAAC,GAAGR,SAAS,EAAE;IACxET,QAAQ,EAAEA,QAAQ;IAClBkB,YAAY,EAAEvB;EAClB,CAAC,CAAC;AACN","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}